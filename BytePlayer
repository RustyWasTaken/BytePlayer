-- 888888b.            888            8888888b.  888                                    
-- 888  "88b           888            888   Y88b 888                                    
-- 888  .88P           888            888    888 888                                    
-- 8888888K.  888  888 888888 .d88b.  888   d88P 888  8888b.  888  888  .d88b.  888d888 
-- 888  "Y88b 888  888 888   d8P  Y8b 8888888P"  888     "88b 888  888 d8P  Y8b 888P"   
-- 888    888 888  888 888   88888888 888        888 .d888888 888  888 88888888 888     
-- 888   d88P Y88b 888 Y88b. Y8b.     888        888 888  888 Y88b 888 Y8b.     888     
-- 8888888P"   "Y88888  "Y888 "Y8888  888        888 "Y888888  "Y88888  "Y8888  888     
--                 888                                             888                  
--            Y8b d88P                                        Y8b d88P                  
--            "Y88P"                                          "Y88P"                   
-- 1.1.8
-- By ImBadAtNamesLol

-- Set the version and changelog
local version = "BytePlayer 1.1.8 [Alpha]"
local changelog = [[
Changelog:
- Added playlist selection based on user input
- Prompt user for playlist file name
- Display changelog for 1 second before running
- Centered artist text at the bottom
- Highlighted the current song in the queue
- Clickable buttons to skip to a specific song
- Queue displays up to 20 songs
]]

-- Find the speaker peripheral and initialize variables
local s = peripheral.find("speaker")
local current = ""
local song = ""
local artist = ""
local dfpwm = require("cc.audio.dfpwm")
local playlist = {}
local currentSongIndex = 1

-- Function to load a playlist based on the given filename
local function loadPlaylist(filename)
    local path = fs.combine(shell.dir(), filename)
    if fs.exists(path) then
        local file = fs.open(path, "r")
        local content = file.readAll()
        file.close()

        local success, result = pcall(loadstring(content))
        if success and result and type(result) == "table" and result.playlist then
            return result.playlist
        else
            print("Error loading playlist: " .. filename)
        end
    else
        print("Playlist not found: " .. filename)
    end

    return {}
end

-- Function to display changelog for a short duration
local function displayChangelog()
    term.clear()
    term.setCursorPos(1, 1)
    print(changelog)
    sleep(1)
    term.clear()
end

-- Display changelog before running
displayChangelog()

-- Prompt the user to input a file name and load the playlist
print("Enter the playlist file name:")
local filename = read()
playlist = loadPlaylist(filename)

-- Function to handle music playback
function music()
    while true do
        for i = currentSongIndex, #playlist do
            local v = playlist[i]
            song = v["title"]
            artist = v["artist"]
            current = v["url"]
            local data = http.get(current, nil, true)
            if data then
                local decoder = dfpwm.make_decoder()
                while true do
                    local chunk = data.read(16 * 1024)
                    if not chunk then
                        break
                    end

                    local buffer = decoder(chunk)
                    while not s.playAudio(buffer) do
                        os.pullEvent("speaker_audio_empty")
                    end
                end
                currentSongIndex = i + 1
            end
            current = ""
        end
        currentSongIndex = 1
        sleep()
    end
end

-- Function to handle the display
function display()
    term.setTextColor(colors.gray)
    term.setBackgroundColor(colors.lightGray)
    term.setCursorBlink(false)

    local screenWidth, screenHeight = term.getSize()

    while true do
        term.clear()

        local xPosition = screenWidth - string.len(version) + 1
        term.setCursorPos(xPosition, 1)
        term.write(version)

        if current then
            local xPositionSong = math.floor((screenWidth - string.len(song)) / 2) + 1
            local yPositionSong = math.floor(screenHeight * 7 / 8) - 1
            term.setCursorPos(xPositionSong, yPositionSong)
            term.write(song)

            local xPositionArtist = math.floor((screenWidth - string.len(artist)) / 2) + 1
            local yPositionArtist = math.floor(screenHeight * 7 / 8)
            term.setCursorPos(xPositionArtist, yPositionArtist)
            term.write(artist)
        else
            term.setCursorPos(1, math.floor(screenHeight * 7 / 8) - 1)
            term.write("Nothing is playing")
        end

        local queueText = "Queue:"
        local xPositionQueue = math.floor((screenWidth - string.len(queueText)) / 2)
        local yPositionQueue = math.floor(screenHeight / 3) - 1

        term.setCursorPos(xPositionQueue, yPositionQueue)
        term.write(queueText)

        for i = 1, math.min(20, #playlist) do
            local title = playlist[i].title .. " | " .. playlist[i].artist
            local xPositionTitle = xPositionQueue + math.floor((string.len(queueText) - string.len(title)) / 2) + 1
            local yPositionTitle = yPositionQueue + i
            term.setCursorPos(xPositionTitle, yPositionTitle)

            if i == currentSongIndex then
                term.setTextColor(colors.white)
                term.setBackgroundColor(colors.gray)
                term.write("> " .. title .. " ")
            else
                term.setTextColor(colors.gray)
                term.setBackgroundColor(colors.lightGray)
                term.write("  " .. title .. " ")
            end
        end

        term.setTextColor(colors.gray)
        term.setBackgroundColor(colors.lightGray)

        local event, button, cx, cy = os.pullEvent()
        if event == "mouse_click" then
            for i = 1, math.min(20, #playlist) do
                local xPositionTitle = xPositionQueue + math.floor((string.len(queueText) - string.len(playlist[i].title .. " | " .. playlist[i].artist)) / 2) + 1
                local yPositionTitle = yPositionQueue + i

                if cx >= xPositionTitle and cx < xPositionTitle + string.len(playlist[i].title .. " | " .. playlist[i].artist) and cy == yPositionTitle and button == 1 then
                    currentSongIndex = i
                end
            end
        end

        sleep()
    end
end

-- Run both functions in parallel
parallel.waitForAll(music, display)
